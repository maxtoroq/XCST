<?xml version="1.0" encoding="utf-8" ?>
<!--
 Copyright 2021 Max Toro Q.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<module version='1.0' language='C#'
   xmlns='http://maxtoroq.github.io/XCST'
   xmlns:xcst='https://maxtoroq.github.io/XCST/grammar'
   xmlns:code='https://maxtoroq.github.io/XCST/code'
   xmlns:src='https://maxtoroq.github.io/XCST/compiled'>

   <import-namespace ns='System.Linq'/>
   <import-namespace ns='System.Xml.Linq'/>

   <variable name='src_all_modes_method_name' value='src_aux_variable("modes")'/>
   <variable name='src_on_no_match_default'>fail</variable>

   <template mode='xcst:validate-top-level' match='XElement el &amp;&amp; el.Name == c + "mode"'/>

   <template mode='xcst:validate-top-level' match='XElement el &amp;&amp; el.Name == c + "template" &amp;&amp; el.Attribute("match") != null'/>

   <template name='xcst:template-rule'>
      <param name='el' as='XElement' required='yes'/>
      <param name='language' as='string' tunnel='yes' required='yes'/>

      <if test='el.Parent?.Name == c + "override"'>
         <variable name='modes' value='xcst_template_modes(el)'/>
         <variable name='mode' value='modes[0]'/>

         <if test='!(modes.Length == 1)'>
            <message terminate='yes' error-code='XCST9106' error-data='src_error_object(el)' transform-text='trim'>
               An overriding template rule should specify a single mode.
            </message>
         </if>

         <if test='!(mode != "#all")'>
            <message terminate='yes' error-code='XCST9105' error-data='src_error_object(el)' transform-text='trim'>
               An overriding template rule cannot use mode='#all'.
            </message>
         </if>

         <variable name='overriddenMeta'>
            <call-template name='xcst:overridden-component'>
               <with-param name='el' value='el'/>
               <with-param name='mode' value='mode'/>
            </call-template>
         </variable>
      </if>

      <variable name='@as' value='
         (el.Attribute("as") is { } asAttr) ?
            xcst_type(asAttr) : null'/>

      <xcst:template-rule
            member-name='{src_template_method_name(el, null, "rule", false)}'
            declaration-id='{fn_generate_id(el)}'
            declaring-module-uri='{el.Document!.BaseUri}'
            cardinality='{(@as != null ? xcst_cardinality(@as, language) : TypeCardinality.ZeroOrMore)}'>
         <for-each name='param' in='el.Elements(c + "param")'>
            <call-template name='xcst:validate-attribs'>
               <with-param name='el' value='param'/>
               <with-param name='required' value='new[] { "name" }'/>
               <with-param name='optional' value='new[] { "value", "as", "required", "tunnel" }'/>
            </call-template>
            <call-template name='xcst:value-or-sequence-constructor'>
               <with-param name='el' value='param'/>
            </call-template>
            <call-template name='xcst:no-other-preceding'>
               <with-param name='el' value='param'/>
            </call-template>
            <variable name='required' value='
               (param.Attribute("required") is { } reqAttr) ?
                  xcst_boolean(reqAttr)!.Value
                  : false'/>
            <variable name='tunnel' value='
               (param.Attribute("tunnel") is { } tunnelAttr) ?
                  xcst_boolean(tunnelAttr)!.Value
                  : false'/>
            <variable name='text' value='xcst_text(param)'/>
            <variable name='hasDefaultValue' value='xcst_has_value(param, text)'/>
            <if test='!(!required || !hasDefaultValue)'>
               <message terminate='yes' error-code='XTSE0010' error-data='src_error_object(param)' transform-text='trim'>
                  The 'value' attribute or child element/text should be omitted when required='yes'.
               </message>
            </if>
            <variable name='paramName' value='xcst_unescape_identifier(xcst_name(param.Attribute("name")!), language)'/>
            <if test='!preceding_sibling(param, param.Name).All(p => !xcst_name_equal(p.Attribute("name")!, paramName))'>
               <message terminate='yes' error-code='XTSE0580' error-data='src_error_object(param)' transform-text='trim'>
                  The name of the parameter is not unique.
               </message>
            </if>
            <xcst:param name='{paramName}' required='{fn_string(required)}' tunnel='{fn_string(tunnel)}'>
               <call-template name='xcst:variable-type'>
                  <with-param name='el' value='param'/>
                  <with-param name='text' value='text'/>
               </call-template>
               <on-empty>
                  <copy-of value='src_nullable_object_type'/>
               </on-empty>
            </xcst:param>
         </for-each>
         <if test='@as != null'>
            <xcst:item-type>
               <code:type-reference name='{xcst_item_type(@as, language)}'/>
            </xcst:item-type>
         </if>
      </xcst:template-rule>
   </template>

   <template name='xcst:explicit-modes' as='XElement[]'>
      <param name='packageEl' as='XElement' required='yes'/>
      <param name='modules' as='XElement[]' tunnel='yes' required='yes'/>
      <param name='implicitPackage' as='bool' tunnel='yes' required='yes'/>

      <variable name='defaultMode' value='xcst_default_mode(packageEl)'/>
      <variable name='rules' value='select(modules, c + "template")
         .Where(p => p.Attribute("match") != null)
         .ToArray()'/>
      <variable name='visibility'>private</variable>
      <variable name='onNoMatch' value='src_on_no_match_default'/>

      <for-each-group name='grp' in='select(modules.Reverse(), c + "mode")'
            group-by='p => (p.Attribute("name") is { } nameAttr) ? xcst_EQName(nameAttr) : (object)""'>
         <sort by='p => p.Key is XName'/>

         <variable name='modeName' value='grp.Key as XName'/>
         <variable name='name' value='(modeName is null) ? "#unnamed" : xcst_uri_qualified_name(modeName)'/>

         <for-each name='mode' in='grp'>

            <void>
               <call-template name='xcst:validate-attribs'>
                  <with-param name='el' value='mode'/>
                  <with-param name='optional' value='new[] { "name", "on-no-match", "visibility" }'/>
               </call-template>

               <call-template name='xcst:no-children'>
                  <with-param name='el' value='mode'/>
               </call-template>
            </void>

            <if test='!(modeName is null
                  || !xcst_is_reserved_namespace(modeName.Namespace))'>
               <message terminate='yes' error-code='XTSE0080' error-data='src_error_object(mode)' expand-text='yes' transform-text='trim'>
                  Namespace prefix '{mode.GetPrefixOfNamespace(modeName.Namespace)}' refers to a reserved namespace.
               </message>
            </if>

            <if test='!preceding_sibling(mode, mode.Name)
                  .Select(p => (p.Attribute("name") is { } nameAttr) ? xcst_EQName(nameAttr) : null)
                  .All(p => (modeName is null) ? p != null : modeName != p)'>
               <message terminate='yes' error-code='XTSE0020' error-data='src_error_object(mode)' transform-text='trim'>
                  Duplicate c:mode declaration.
               </message>
            </if>

            <if test='mode.Attribute("visibility") is { } visibilityAttr'>
               <variable name='modeVisibility' value='xcst_visibility(visibilityAttr)'/>
               <if test='!(modeVisibility is not ("abstract" or "hidden"))'>
                  <message terminate='yes' error-code='XTSE0020' error-data='src_error_object(mode)' expand-text='yes' transform-text='trim'>
                     visibility='{modeVisibility}' is not a valid value for c:mode declarations.
                  </message>
               </if>
               <if test='!(modeName != null || modeVisibility == "private")'>
                  <message terminate='yes' error-code='XTSE0020' error-data='src_error_object(mode)' expand-text='yes' transform-text='trim'>
                     visibility='{modeVisibility}' is not a valid value for unnamed c:mode declarations.
                  </message>
               </if>
               <set ref='visibility' value='modeVisibility'/>
            </if>

            <if test='mode.Attribute("on-no-match") is { } onNoMatchAttr'>
               <variable name='modeOnNoMatch' value='xcst_non_string(onNoMatchAttr)'/>
               <if test='!(modeOnNoMatch is "deep-copy" or "shallow-copy" or "deep-skip" or "shallow-skip" or "text-only-copy" or "fail")'>
                  <message terminate='yes' error-code='XTSE0020' error-data='src_error_object(mode)' transform-text='trim'>
                     Invalid value for '{fn_name(onNoMatchAttr)}'. Must be one of (deep-copy|shallow-copy|deep-skip|shallow-skip|text-only-copy|fail).
                  </message>
               </if>
               <set ref='onNoMatch' value='modeOnNoMatch'/>
            </if>
         </for-each>

         <variable name='memberName' value='
            (modeName is null) ?
               src_aux_variable("mode_")
               : src_template_method_name(null, modeName, "mode", true)'/>

         <variable name='isDefault' value='name == defaultMode'/>
         <variable name='initial' value='
            isDefault
               || (visibility is "public" or "final")
               || implicitPackage'/>

         <xcst:mode
               name='{name}'
               member-name='{memberName}'
               declaration-id='{fn_generate_id(grp.First())}'
               default='{fn_string(isDefault)}'
               initial='{fn_string(initial)}'
               on-no-match='{onNoMatch}'
               visibility='{visibility}'>
            <variable name='includeModes' value='new[] { name, "#all" }'/>
            <for-each name='rule' in='rules.Where(p => xcst_template_modes(p)
                  .Intersect(includeModes).Any())'>
               <xcst:template-rule-ref id='{fn_generate_id(rule)}'/>
            </for-each>
         </xcst:mode>
      </for-each-group>
   </template>

   <template name='xcst:implicit-modes' as='XElement[]'>
      <param name='packageEl' as='XElement' required='yes'/>
      <param name='explicitModes' as='XElement[]' required='yes'/>
      <param name='modules' as='XElement[]' tunnel='yes' required='yes'/>
      <param name='implicitPackage' as='bool' tunnel='yes' required='yes'/>

      <variable name='rules' value='select(modules, c + "template")
         .Where(p => p.Attribute("match") != null)
         .ToArray()'/>

      <variable name='tmplModes' value='rules
         .SelectMany(p => xcst_template_modes(p))
         .ToArray()'/>

      <variable name='modes' value='tmplModes
         .Where(p => p != "#all")
         .Distinct()'/>

      <variable name='defaultMode' value='xcst_default_mode(packageEl)'/>

      <for-each name='mode' in='modes.Where(p => explicitModes.All(p2 => p2.Attribute("name")!.Value != p))'>
         <variable name='memberName' value='
            (mode == "#unnamed") ?
               src_aux_variable("mode_")
               : src_template_method_name(null, xcst_URIQualifiedName(mode), "mode", true)'/>
         <variable name='isDefault' value='mode == defaultMode'/>
         <variable name='initial' value='isDefault || implicitPackage'/>
         <variable name='includeModes' value='new[] { mode, "#all" }'/>
         <variable name='modeRules' value='rules.Where(p => xcst_template_modes(p).Intersect(includeModes).Any())
            .ToArray()'/>
         <xcst:mode
               name='{mode}'
               member-name='{memberName}'
               declaration-id='{fn_generate_id(modeRules[0])}'
               default='{fn_string(isDefault)}'
               initial='{fn_string(initial)}'
               on-no-match='{src_on_no_match_default}'
               visibility='private'>
            <for-each name='rule' in='modeRules'>
               <xcst:template-rule-ref id='{fn_generate_id(rule)}'/>
            </for-each>
         </xcst:mode>
      </for-each>
   </template>

   <template name='xcst:overriding-modes' as='XElement[]'>
      <param name='packageEl' as='XElement' required='yes'/>
      <param name='modules' as='XElement[]' tunnel='yes' required='yes'/>
      <param name='@namespace' as='string' tunnel='yes' required='yes'/>
      <param name='implicitPackage' as='bool' tunnel='yes' required='yes'/>

      <variable name='defaultMode' value='xcst_default_mode(packageEl)'/>

      <for-each-group name='grp' in='select(modules, c + "use-package")
            .Where(p => select(p, c + "override", c + "template").Where(p2 => p2.Attribute("match") != null).Any())'
            group-by='p => src_resolve_package_name(p, @namespace)'>

         <for-each-group name='rules' in='select(grp, c + "override", c + "template").Where(p => p.Attribute("match") != null)'
               group-by='p => xcst_template_modes(p)[0]'>

            <variable name='mode' value='rules.Key'/>
            <variable name='first' value='rules.First()'/>
            <variable name='memberName' value='src_template_method_name(null, xcst_URIQualifiedName(mode), "mode", true)'/>
            <variable name='isDefault' value='mode == defaultMode'/>
            <variable name='initial' value='isDefault || implicitPackage'/>

            <variable name='overriddenMeta'>
               <call-template name='xcst:overridden-component'>
                  <with-param name='el' value='first'/>
                  <with-param name='mode' value='mode'/>
               </call-template>
            </variable>

            <xcst:mode
                  name='{mode}'
                  member-name='{memberName}'
                  declaration-id='{fn_generate_id(first)}'
                  default='{fn_string(isDefault)}'
                  initial='{fn_string(initial)}'
                  overrides='{fn_generate_id(overriddenMeta!)}'
                  visibility='private'>
               <for-each name='rule' in='rules'>
                  <xcst:template-rule-ref id='{fn_generate_id(rule)}'/>
               </for-each>
            </xcst:mode>
         </for-each-group>
      </for-each-group>
   </template>

   <function name='xcst_default_mode' as='string'>
      <param name='el' as='XElement'/>

      <return value='el.AncestorsAndSelf()
         .Where(p => p.Name == c + "module" || p.Name == c + "package")
         .Select(p => (p.Attribute("default-mode") is { } defaultModeAttr) ?
            xcst_uri_qualified_name(xcst_EQName(defaultModeAttr)!) : null)
         .First()
         ?? "#unnamed"'/>
   </function>

   <function name='xcst_template_modes' as='string[]'>
      <param name='el' as='XElement'/>

      <variable name='defaultMode' value='xcst_default_mode(el)'/>
      <choose>
         <when test='el.Attribute("mode") is { } modeAttr'>
            <variable name='modes' value='
               fn_tokenize(xcst_non_string(modeAttr))
                  .Select(m =>
                     (m == "#all") ? m
                     : (m == "#default") ? defaultMode
                     : (object)xcst_EQName(el, m)!)
                  .ToArray()'/>
            <if test='!(modes.Length == 1
                  || modes.All(p => !p.Equals("#all")))'>
               <message terminate='yes' error-code='XTSE0550' error-data='src_error_object(el)' transform-text='trim'>
                  mode='#all' cannot be combined with other modes.
               </message>
            </if>
            <if test='!(modes.Distinct().Count() == modes.Length)'>
               <message terminate='yes' error-code='XTSE0550' error-data='src_error_object(el)' transform-text='trim'>
                  The list of modes cannot contain duplicates.
               </message>
            </if>
            <variable name='reservedQname' value='modes.OfType&lt;XName>()
               .FirstOrDefault(p => xcst_is_reserved_namespace(p.Namespace))'/>
            <if test='!(reservedQname is null)'>
               <message terminate='yes' error-code='XTSE0080' error-data='src_error_object(el)' expand-text='yes' transform-text='trim'>
                  Namespace prefix '{el.GetPrefixOfNamespace(reservedQname.Namespace)}' refers to a reserved namespace.
               </message>
            </if>
            <return value='modes.Select(p =>
               (p is XName qname) ?
                  xcst_uri_qualified_name(qname)
                  : (string)p)
               .ToArray()'/>
         </when>
         <otherwise>
            <return value='new[] { defaultMode }'/>
         </otherwise>
      </choose>
   </function>


   <!-- ## Library Package -->

   <template mode='src:member' match='XElement el &amp;&amp; el.Name == xcst + "mode"
      &amp;&amp; (bool?)el.Attribute("accepted") == true'/>

   <template mode='src:lib-overriding-type' match='XElement el &amp;&amp; el.Name == xcst + "mode"'>
      <code:type-reference name='Action' namespace='System'>
         <code:type-arguments>
            <copy-of value='src_template_context(el).Element(code + "type-reference")'/>
            <copy-of value='src_template_output(el).Element(code + "type-reference")'/>
            <code:type-reference name='Int32' namespace='System'/>
         </code:type-arguments>
      </code:type-reference>
   </template>

   <template  mode='src:lib-override' match='XElement el &amp;&amp; el.Name == xcst + "mode"'>

      <variable name='tbaseParam'>
         <code:parameter name='TBase'/>
      </variable>

      <variable name='auxMeta'>
         <xcst:aux-method>
            <xcst:item-type>
               <code:type-reference name='{tbaseParam.Attribute("name")!.Value}'/>
            </xcst:item-type>
         </xcst:aux-method>
      </variable>

      <variable name='context' value='src_template_context(el)'/>
      <variable name='output' value='src_template_output(auxMeta)'/>

      <variable name='offsetParam'>
         <code:variable-reference name='{src_aux_variable("match_offset")}'/>
      </variable>

      <code:method name='{el.Attribute("member-name")!.Value}' visibility='public' extensibility='override'>
         <code:type-parameters>
            <copy-of value='tbaseParam'/>
         </code:type-parameters>
         <code:parameters>
            <code:parameter name='{select(context, src + "reference", code).First().Attribute("name")!.Value}'>
               <copy-of value='context.Element(code + "type-reference")'/>
            </code:parameter>
            <code:parameter name='{select(output, src + "reference", code).First().Attribute("name")!.Value}'>
               <copy-of value='output.Element(code + "type-reference")'/>
            </code:parameter>
            <code:parameter name='{offsetParam.Attribute("name")!.Value}'>
               <code:type-reference name='Int32' namespace='System'/>
               <code:int value='0'/>
            </code:parameter>
         </code:parameters>
         <code:block>
            <code:method-call name='{src_overriding_field_name(el)}'>
               <code:this-reference/>
               <code:arguments>
                  <copy-of value='select(context, src + "reference", code)'/>
                  <code:method-call name='AdjustWriterDynamically'>
                     <copy-of value='src_helper_type("SequenceWriter")'/>
                     <code:arguments>
                        <copy-of value='select(output, src + "reference", code)'/>
                        <copy-of value='src_item_type_inference_member_ref(el)'/>
                     </code:arguments>
                  </code:method-call>
                  <copy-of value='offsetParam'/>
               </code:arguments>
            </code:method-call>
         </code:block>
      </code:method>
   </template>

   <template mode='src:lib-original' match='XElement el &amp;&amp; el.Name == xcst + "mode"'>

      <variable name='tbaseParam'>
         <code:parameter name='TBase'/>
      </variable>

      <variable name='auxMeta'>
         <xcst:aux-method>
            <xcst:item-type>
               <code:type-reference name='{tbaseParam.Attribute("name")!.Value}'/>
            </xcst:item-type>
         </xcst:aux-method>
      </variable>

      <variable name='context' value='src_template_context(el)'/>
      <variable name='output' value='src_template_output(auxMeta)'/>

      <variable name='offsetParam'>
         <code:variable-reference name='{src_aux_variable("match_offset")}'/>
      </variable>

      <code:method name='{src_original_member_name(el)}' visibility='internal'>
         <code:type-parameters>
            <copy-of value='tbaseParam'/>
         </code:type-parameters>
         <code:parameters>
            <code:parameter name='{select(context, src + "reference", code).First().Attribute("name")!.Value}'>
               <copy-of value='context.Element(code + "type-reference")'/>
            </code:parameter>
            <code:parameter name='{select(output, src + "reference", code).First().Attribute("name")!.Value}'>
               <copy-of value='output.Element(code + "type-reference")'/>
            </code:parameter>
            <code:parameter name='{offsetParam.Attribute("name")!.Value}'>
               <code:type-reference name='Int32' namespace='System'/>
            </code:parameter>
         </code:parameters>
         <code:block>
            <code:method-call name='{el.Attribute("member-name")!.Value}'>
               <code:base-reference/>
               <code:arguments>
                  <copy-of value='select(context, src + "reference", code)'/>
                  <copy-of value='select(output, src + "reference", code)'/>
                  <copy-of value='offsetParam'/>
               </code:arguments>
            </code:method-call>
         </code:block>
      </code:method>
   </template>


   <!-- ## Top Package -->

   <template mode='src:lib-overriding-value' match='XElement el &amp;&amp; el.Name == xcst + "mode"'>
      <param name='meta' as='XElement' required='yes'/>

      <code:method-reference name='{meta.Attribute("member-name")!.Value}'>
         <code:this-reference/>
      </code:method-reference>
   </template>

   <template match='XElement el &amp;&amp; el.Name == c + "template" &amp;&amp; el.Attribute("match") is { } matchAttr' mode='src:member'>
      <param name='packageManifest' as='XElement' tunnel='yes' required='yes'/>

      <variable name='id' value='fn_generate_id(el)'/>

      <variable name='meta' value='packageManifest
         .Elements(xcst + "template-rule")
         .First(p => p.Attribute("declaration-id")?.Value == id)'/>

      <variable name='cardinality' value='(TypeCardinality)System.Enum.Parse(typeof(TypeCardinality), meta.Attribute("cardinality")!.Value)'/>

      <variable name='tbaseParam'>
         <code:parameter name='TBase'/>
      </variable>

      <variable name='auxMeta'>
         <xcst:aux-method>
            <xcst:item-type>
               <code:type-reference name='{tbaseParam.Attribute("name")!.Value}'/>
            </xcst:item-type>
         </xcst:aux-method>
      </variable>

      <variable name='context' value='src_template_context(meta)'/>
      <variable name='output' value='src_template_output(auxMeta)'/>

      <variable name='matchParam'>
         <code:parameter name='{src_aux_variable("match")}' ref='true'>
            <code:type-reference name='Boolean' namespace='System'/>
         </code:parameter>
      </variable>

      <variable name='itemType' value='select(meta, xcst + "item-type", code + "type-reference")
         .FirstOrDefault()'/>

      <code:method name='{meta.Attribute("member-name")!.Value}' visibility='private'>
         <code:attributes>
            <call-template name='src:editor-browsable-never'/>
         </code:attributes>
         <code:type-parameters>
            <copy-of value='tbaseParam'/>
         </code:type-parameters>
         <code:parameters>
            <code:parameter name='{select(context, src + "reference", code).First().Attribute("name")!.Value}'>
               <copy-of value='context.Element(code + "type-reference")'/>
            </code:parameter>
            <code:parameter name='{select(output, src + "reference", code).First().Attribute("name")!.Value}'>
               <copy-of value='output.Element(code + "type-reference")'/>
            </code:parameter>
            <copy-of value='matchParam'/>
         </code:parameters>
         <code:block>
            <code:if>
               <code:not>
                  <code:is>
                     <code:property-reference name='Input'>
                        <copy-of value='select(context, src + "reference", code)'/>
                     </code:property-reference>
                     <code:expression value='{xcst_expression(matchAttr)}'/>
                  </code:is>
               </code:not>
               <code:block>
                  <code:return/>
               </code:block>
            </code:if>
            <code:assign>
               <code:variable-reference name='{matchParam.Attribute("name")!.Value}'/>
               <code:bool value='true'/>
            </code:assign>
            <variable name='outputAdj' value='src_template_output(meta, el)'/>
            <code:variable name='{select(outputAdj, src + "reference", code).First().Attribute("name")!.Value}'>
               <call-template name='src:call-template-output'>
                  <with-param name='meta' value='meta'/>
                  <with-param name='output' value='output' tunnel='yes'/>
                  <with-param name='dynamic' value='true'/>
               </call-template>
            </code:variable>
            <for-each name='param' in='el.Elements(c + "param")'>
               <call-template name='src:param-var'>
                  <with-param name='el' value='param'/>
                  <with-param name='context' value='context' tunnel='yes'/>
               </call-template>
            </for-each>
            <call-template name='src:sequence-constructor'>
               <with-param name='el' value='el'/>
               <with-param name='children' value='el
                  .Nodes()
                  .Except(el.Nodes()
                     .Where(p => (p is XElement p2 &amp;&amp; p2.Name == c + "param")
                        || p.ElementsAfterSelf(c + "param").Any()))
                  .ToArray()'/>
               <with-param name='trackCardinality' value='cardinality'/>
               <with-param name='itemType' value='itemType'/>
               <with-param name='context' value='context' tunnel='yes'/>
               <with-param name='output' value='outputAdj' tunnel='yes'/>
            </call-template>
         </code:block>
      </code:method>

      <if test='itemType != null'>
         <code:method name='{src_item_type_inference_member_name(meta)}'
               visibility='private'
               extensibility='static'
               line-hidden='true'>
            <copy-of value='itemType'/>
            <code:attributes>
               <call-template name='src:editor-browsable-never'/>
            </code:attributes>
            <code:block>
               <code:throw>
                  <code:method-call name='InferMethodIsNotMeantToBeCalled'>
                     <copy-of value='src_helper_type("DynamicError")'/>
                  </code:method-call>
               </code:throw>
            </code:block>
         </code:method>
      </if>
   </template>

   <template match='XElement el &amp;&amp; el.Name == xcst + "mode"
         &amp;&amp; !((bool?)el.Attribute("accepted") ?? false)' mode='src:member'>
      <param name='packageManifest' as='XElement' tunnel='yes' required='yes'/>

      <variable name='tbaseParam'>
         <code:parameter name='TBase'/>
      </variable>

      <variable name='auxMeta'>
         <xcst:aux-method>
            <xcst:item-type>
               <code:type-reference name='{tbaseParam.Attribute("name")!.Value}'/>
            </xcst:item-type>
         </xcst:aux-method>
      </variable>

      <variable name='context' value='src_template_context(null)'/>
      <variable name='output' value='src_template_output(auxMeta)'/>
      <variable name='visibility' value='el.Attribute("visibility")!.Value'/>
      <variable name='publicMember' value='visibility is "public" or "final"'/>

      <variable name='offsetParam'>
         <code:variable-reference name='{src_aux_variable("match_offset")}'/>
      </variable>

      <code:method name='{el.Attribute("member-name")!.Value}'
            visibility='{(publicMember ? "public" : "private")}'
            extensibility='{(visibility == "public" ? "virtual" : "#default")}'>
         <code:attributes>
            <if test='publicMember'>
               <variable name='qname' value='xcst_EQName(el.Attribute("name")!)!'/>
               <code:attribute>
                  <copy-of value='src_component_attr_type'/>
                  <code:arguments>
                     <code:int value='7'/>
                  </code:arguments>
                  <code:initializer>
                     <code:member-initializer name='Name'>
                        <code:string verbatim='true'>
                           <value-of value='xcst_uri_qualified_name(qname)'/>
                        </code:string>
                     </code:member-initializer>
                  </code:initializer>
               </code:attribute>
            </if>
            <call-template name='src:editor-browsable-never'/>
         </code:attributes>
         <code:type-parameters>
            <copy-of value='tbaseParam'/>
         </code:type-parameters>
         <code:parameters>
            <code:parameter name='{select(context, src + "reference", code).First().Attribute("name")!.Value}'>
               <copy-of value='context.Element(code + "type-reference")'/>
            </code:parameter>
            <code:parameter name='{select(output, src + "reference", code).First().Attribute("name")!.Value}'>
               <copy-of value='output.Element(code + "type-reference")'/>
            </code:parameter>
            <code:parameter name='{offsetParam.Attribute("name")!.Value}'>
               <code:type-reference name='Int32' namespace='System'/>
               <code:int value='0'/>
            </code:parameter>
         </code:parameters>
         <code:block>
            <variable name='rules' value='el
               .Elements(xcst + "template-rule-ref")
               .Reverse()
               .ToArray()'/>
            <variable name='overridesAttr' value='el.Attribute("overrides")'/>
            <if test='rules.Length > 0'>
               <variable name='indexRef'>
                  <code:property-reference name='MatchIndex'>
                     <copy-of value='select(context, src + "reference", code)'/>
                  </code:property-reference>
               </variable>
               <variable name='matchVar'>
                  <code:variable name='match'>
                     <code:type-reference name='Boolean' namespace='System'/>
                     <code:bool value='false'/>
                  </code:variable>
               </variable>
               <copy-of value='matchVar'/>
               <variable name='i' value='-1'/>
               <for-each name='rule' in='rules'>
                  <void value='i++'/>
                  <variable name='meta' value='select(packageManifest, xcst + "template-rule")
                     .First(p => p.Attribute("declaration-id")!.Value == rule.Attribute("id")!.Value)'/>
                  <code:if>
                     <code:equal>
                        <copy-of value='indexRef'/>
                        <code:add>
                           <code:int value='{fn_string(i)}'/>
                           <copy-of value='offsetParam'/>
                        </code:add>
                     </code:equal>
                     <code:block>
                        <code:method-call>
                           <copy-of value='src_template_member(meta)'/>
                           <code:arguments>
                              <copy-of value='select(context, src + "reference", code)'/>
                              <copy-of value='select(output, src + "reference", code)'/>
                              <code:argument ref='true'>
                                 <code:variable-reference name='{matchVar.Attribute("name")!.Value}'/>
                              </code:argument>
                           </code:arguments>
                        </code:method-call>
                        <code:if>
                           <code:variable-reference name='{matchVar.Attribute("name")!.Value}'/>
                           <code:block>
                              <code:return/>
                           </code:block>
                        </code:if>
                        <if test='i &lt; rules.Length - 1
                              || overridesAttr != null'>
                           <code:method-call name='NextMatch'>
                              <copy-of value='select(context, src + "reference", code)'/>
                           </code:method-call>
                        </if>
                     </code:block>
                  </code:if>
               </for-each>
            </if>
            <choose>
               <when test='overridesAttr != null'>
                  <variable name='originalMeta' value='packageManifest
                     .Elements(xcst + "mode")
                     .First(p => p.Attribute("id")!.Value == overridesAttr.Value)'/>
                  <code:method-call>
                     <copy-of value='src_original_member(originalMeta)'/>
                     <code:arguments>
                        <copy-of value='select(context, src + "reference", code)'/>
                        <copy-of value='select(output, src + "reference", code)'/>
                        <code:add>
                           <copy-of value='offsetParam'/>
                           <code:int value='{rules.Length}'/>
                        </code:add>
                     </code:arguments>
                  </code:method-call>
               </when>
               <otherwise>
                  <switch value='el.Attribute("on-no-match")!.Value'>
                     <when test='"deep-copy"'>
                        <code:method-call name='Copy'>
                           <copy-of value='src_helper_type("DeepCopy")'/>
                           <code:arguments>
                              <code:this-reference/>
                              <copy-of value='select(context, src + "reference", code)'/>
                              <copy-of value='select(output, src + "reference", code)'/>
                           </code:arguments>
                        </code:method-call>
                     </when>
                     <when test='"shallow-copy"'>
                        <code:method-call name='Copy'>
                           <copy-of value='src_helper_type("ShallowCopy")'/>
                           <code:arguments>
                              <code:this-reference/>
                              <code:method-reference name='{el.Attribute("member-name")!.Value}'>
                                 <code:this-reference/>
                              </code:method-reference>
                              <copy-of value='select(context, src + "reference", code)'/>
                              <copy-of value='select(output, src + "reference", code)'/>
                              <copy-of value='offsetParam'/>
                           </code:arguments>
                        </code:method-call>
                     </when>
                     <when test='"deep-skip"'>
                        <code:method-call name='Skip'>
                           <copy-of value='src_helper_type("DeepSkip")'/>
                           <code:arguments>
                              <code:this-reference/>
                              <code:method-reference name='{el.Attribute("member-name")!.Value}'>
                                 <code:this-reference/>
                              </code:method-reference>
                              <copy-of value='select(context, src + "reference", code)'/>
                              <copy-of value='select(output, src + "reference", code)'/>
                              <copy-of value='offsetParam'/>
                           </code:arguments>
                        </code:method-call>
                     </when>
                     <when test='"shallow-skip"'>
                        <code:method-call name='Skip'>
                           <copy-of value='src_helper_type("ShallowSkip")'/>
                           <code:arguments>
                              <code:this-reference/>
                              <code:method-reference name='{el.Attribute("member-name")!.Value}'>
                                 <code:this-reference/>
                              </code:method-reference>
                              <copy-of value='select(context, src + "reference", code)'/>
                              <copy-of value='select(output, src + "reference", code)'/>
                              <copy-of value='offsetParam'/>
                           </code:arguments>
                        </code:method-call>
                     </when>
                     <when test='"text-only-copy"'>
                        <code:method-call name='Copy'>
                           <copy-of value='src_helper_type("TextOnlyCopy")'/>
                           <code:arguments>
                              <code:this-reference/>
                              <code:method-reference name='{el.Attribute("member-name")!.Value}'>
                                 <code:this-reference/>
                              </code:method-reference>
                              <copy-of value='select(context, src + "reference", code)'/>
                              <copy-of value='select(output, src + "reference", code)'/>
                              <copy-of value='offsetParam'/>
                           </code:arguments>
                        </code:method-call>
                     </when>
                     <when test='"fail"'>
                        <code:method-call name='Fail'>
                           <copy-of value='src_helper_type("FailMode")'/>
                           <code:arguments>
                              <code:this-reference/>
                              <copy-of value='select(context, src + "reference", code)'/>
                              <copy-of value='select(output, src + "reference", code)'/>
                           </code:arguments>
                        </code:method-call>
                     </when>
                  </switch>
               </otherwise>
            </choose>
         </code:block>
      </code:method>
   </template>

   <template name='src:get-mode-method'>
      <param name='allModes' value='false' as='bool'/>
      <param name='packageManifest' as='XElement' tunnel='yes' required='yes'/>

      <variable name='nameParam'>
         <code:variable-reference name='{src_aux_variable("name")}'/>
      </variable>

      <variable name='tbaseParam'>
         <code:parameter name='TBase'/>
      </variable>

      <variable name='auxMeta'>
         <xcst:aux-method>
            <xcst:item-type>
               <code:type-reference name='{tbaseParam.Attribute("name")!.Value}'/>
            </xcst:item-type>
         </xcst:aux-method>
      </variable>

      <variable name='context' value='src_template_context(null)'/>
      <variable name='output' value='src_template_output(auxMeta)'/>

      <code:method name='{(allModes ? src_all_modes_method_name : "GetMode")}' visibility='private'>
         <code:type-reference name='Action' namespace='System'>
            <if test='!allModes'>
               <attribute name='nullable'>true</attribute>
            </if>
            <code:type-arguments>
               <copy-of value='context.Element(code + "type-reference")'/>
            </code:type-arguments>
         </code:type-reference>
         <if test='!allModes'>
            <code:implements-interface>
               <copy-of value='src_package_interface'/>
            </code:implements-interface>
         </if>
         <code:type-parameters>
            <copy-of value='tbaseParam'/>
         </code:type-parameters>
         <code:parameters>
            <code:parameter name='{nameParam.Attribute("name")!.Value}'>
               <copy-of value='src_nullable_qname_type'/>
            </code:parameter>
            <code:parameter name='{select(output, src + "reference", code).First().Attribute("name")!.Value}'>
               <copy-of value='output.Element(code + "type-reference")'/>
            </code:parameter>
         </code:parameters>
         <code:block>
            <variable name='modes' value='packageManifest
               .Elements(xcst + "mode")
               .Where(p => p.Attribute("visibility")!.Value != "hidden")
               .Where(p => allModes || xs_boolean(p.Attribute("initial")!))
               .ToArray()'/>
            <variable name='@default' value='modes
               .FirstOrDefault(p => xs_boolean(p.Attribute("default")!))'/>
            <variable name='unknownStatement'>
               <choose>
                  <when test='allModes'>
                     <code:throw>
                        <code:method-call name='UnknownMode'>
                           <copy-of value='src_helper_type("DynamicError")'/>
                           <code:arguments>
                              <copy-of value='nameParam'/>
                           </code:arguments>
                        </code:method-call>
                     </code:throw>
                  </when>
                  <otherwise>
                     <code:return>
                        <code:null/>
                     </code:return>
                  </otherwise>
               </choose>
            </variable>
            <code:if-else>
               <code:if>
                  <code:equal>
                     <copy-of value='nameParam'/>
                     <code:null/>
                  </code:equal>
                  <code:block>
                     <choose>
                        <when test='@default != null'>
                           <code:return>
                              <code:lambda void='true'>
                                 <code:parameters>
                                    <code:parameter name='{select(context, src + "reference", code).First().Attribute("name")!.Value}'/>
                                 </code:parameters>
                                 <code:method-call name='{@default.Attribute("member-name")!.Value}'>
                                    <code:this-reference/>
                                    <code:arguments>
                                       <copy-of value='select(context, src + "reference", code)'/>
                                       <copy-of value='select(output, src + "reference", code)'/>
                                    </code:arguments>
                                 </code:method-call>
                              </code:lambda>
                           </code:return>
                        </when>
                        <otherwise>
                           <copy-of value='unknownStatement'/>
                        </otherwise>
                     </choose>
                  </code:block>
               </code:if>
               <code:else>
                  <code:switch>
                     <code:property-reference name='Namespace{(V2_OR_GREATER ? "Name" : null)}'>
                        <copy-of value='nameParam'/>
                     </code:property-reference>
                     <for-each-group name='grp' in='modes
                           .Where(p => p.Attribute("name")!.Value != "#unnamed")' group-by='p => xcst_EQName(p.Attribute("name")!)!.Namespace'>
                        <sort by='g => g.Count()' order='descending'/>

                        <code:case>
                           <code:string verbatim='true'>
                              <value-of value='grp.Key.NamespaceName'/>
                           </code:string>
                           <code:switch>
                              <code:property-reference name='{(V2_OR_GREATER ? "Local" : null)}Name'>
                                 <copy-of value='nameParam'/>
                              </code:property-reference>
                              <for-each name='mode' in='grp'>
                                 <variable name='qname' value='xcst_EQName(mode.Attribute("name")!)!'/>

                                 <code:case>
                                    <code:string literal='true'>
                                       <value-of value='qname.LocalName'/>
                                    </code:string>
                                    <code:return>
                                       <code:lambda void='true'>
                                          <code:parameters>
                                             <code:parameter name='{select(context, src + "reference", code).First().Attribute("name")!.Value}'/>
                                          </code:parameters>
                                          <code:method-call name='{mode.Attribute("member-name")!.Value}'>
                                             <choose>
                                                <when test='!((bool?)mode.Attribute("accepted") ?? false)'>
                                                   <code:this-reference/>
                                                </when>
                                                <otherwise>
                                                   <code:field-reference name='{src_lib_field_name(mode)}'>
                                                      <code:this-reference/>
                                                   </code:field-reference>
                                                </otherwise>
                                             </choose>
                                             <code:arguments>
                                                <copy-of value='select(context, src + "reference", code)'/>
                                                <copy-of value='select(output, src + "reference", code)'/>
                                             </code:arguments>
                                          </code:method-call>
                                       </code:lambda>
                                    </code:return>
                                 </code:case>
                              </for-each>
                              <code:case-default>
                                 <copy-of value='unknownStatement'/>
                              </code:case-default>
                           </code:switch>
                        </code:case>
                     </for-each-group>
                     <code:case-default>
                        <copy-of value='unknownStatement'/>
                     </code:case-default>
                  </code:switch>
               </code:else>
            </code:if-else>
         </code:block>
      </code:method>
   </template>

   <template name='src:qname-fields'>
      <param name='packageManifest' as='XElement' tunnel='yes' required='yes'/>

      <for-each name='mode' in='packageManifest.Elements(xcst + "mode")
            .Where(p => p.Attribute("visibility")!.Value != "hidden"
               &amp;&amp; p.Attribute("name")!.Value != "#unnamed")'>

         <variable name='qname' value='xcst_URIQualifiedName(mode.Attribute("name")!.Value)'/>

         <code:field name='{src_mode_qname_field(mode)}' extensibility='static' readonly='true'>
            <copy-of value='src_qname_type'/>
            <code:expression>
               <call-template name='src:QName'>
                  <with-param name='qname' value='qname'/>
               </call-template>
            </code:expression>
         </code:field>
      </for-each>
   </template>

   <function name='src_mode_qname_field' as='string'>
      <param name='meta' as='XElement'/>

      <assert test='meta.Name == xcst + "mode"'/>

      <return value='src_aux_variable("qname_" + fn_generate_id(meta))'/>
   </function>


   <!-- ## Instructions -->

   <template match='XElement el &amp;&amp; el.Name == c + "apply-templates"' mode='src:statement'>
      <param name='packageManifest' as='XElement' tunnel='yes' required='yes'/>
      <param name='context' as='XElement?' tunnel='yes'/>
      <param name='output' as='XElement' tunnel='yes'/>

      <call-template name='xcst:validate-attribs'>
         <with-param name='el' value='el'/>
         <with-param name='required' value='new[] { "value" }'/>
         <with-param name='optional' value='new[] { "mode", "with-params", "tunnel-params", "separator" }'/>
      </call-template>

      <variable name='modeAttr' value='el.Attribute("mode")'/>

      <variable name='mode' value='
         (modeAttr != null) ? xcst_non_string(modeAttr) : "#current"'/>

      <variable name='modeUQname' as='string'>
         <switch value='mode'>
            <when test='"#current"' value='src_this_rule_mode(el) ?? mode'/>
            <when test='"#default"' value='xcst_default_mode(el)'/>
            <otherwise value='xcst_uri_qualified_name(xcst_EQName(modeAttr)!)'/>
         </switch>
      </variable>

      <call-template name='xcst:validate-children'>
         <with-param name='el' value='el'/>
         <with-param name='allowed' value='new[] { "with-param" }'/>
      </call-template>

      <call-template name='xcst:validate-with-param'>
         <with-param name='el' value='el'/>
      </call-template>

      <call-template name='xcst:require-output'>
         <with-param name='el' value='el'/>
      </call-template>

      <variable name='meta' as='XElement?'>
         <if test='modeUQname != "#current"'>
            <variable name='m' value='packageManifest
               .Elements(xcst + "mode")
               .FirstOrDefault(p => p.Attribute("visibility")!.Value != "hidden"
                  &amp;&amp; p.Attribute("name")!.Value == modeUQname)'/>
            <if test='!(m != null)'>
               <message terminate='yes' error-code='XCST9103' error-data='src_error_object(el)' expand-text='yes' transform-text='trim'>
                  The mode '{(mode[0] == '#' ? modeUQname : mode)}' does not exist.
               </message>
            </if>
            <object value='m'/>
         </if>
      </variable>

      <code:method-call name='Apply'>
         <call-template name='src:line-number'>
            <with-param name='el' value='el'/>
         </call-template>
         <copy-of value='src_helper_type("ApplyTemplates")'/>
         <code:arguments>
            <call-template name='src:call-template-context'>
               <with-param name='el' value='el'/>
            </call-template>
            <code:expression value='{xcst_expression(el.Attribute("value")!)}'/>
            <switch value='modeUQname'>
               <when test='"#current"'>
                  <choose>
                     <when test='context != null'>
                        <code:property-reference name='Mode'>
                           <copy-of value='select(context, src + "reference", code)'/>
                        </code:property-reference>
                     </when>
                     <otherwise>
                        <code:null/>
                     </otherwise>
                  </choose>
               </when>
               <when test='"#unnamed"'>
                  <code:null/>
               </when>
               <otherwise>
                  <code:field-reference name='{src_mode_qname_field(meta!)}'>
                     <code:type-reference name='{packageManifest.Element(code + "type-reference")!.Attribute("name")!.Value}'/>
                  </code:field-reference>
               </otherwise>
            </switch>
            <choose>
               <when test='meta != null'>
                  <code:lambda void='true'>
                     <variable name='ctx' value='src_template_context(null, el)'/>
                     <code:parameters>
                        <code:parameter name='{select(ctx, src + "reference", code).First().Attribute("name")!.Value}'/>
                     </code:parameters>
                     <code:method-call>
                        <copy-of value='src_template_member(meta)'/>
                        <code:arguments>
                           <copy-of value='select(ctx, src + "reference", code)'/>
                           <copy-of value='select(output, src + "reference", code)'/>
                        </code:arguments>
                     </code:method-call>
                  </code:lambda>
               </when>
               <otherwise>
                  <code:method-call name='{src_all_modes_method_name}'>
                     <code:this-reference/>
                     <code:arguments>
                        <code:property-reference name='Mode'>
                           <copy-of value='select(context, src + "reference", code)'/>
                        </code:property-reference>
                        <copy-of value='select(output, src + "reference", code)'/>
                     </code:arguments>
                  </code:method-call>
               </otherwise>
            </choose>
            <if test='el.Attribute("separator") is { } separatorAttr'>
               <copy-of value='select(output, src +"reference", code)'/>
               <call-template name='src:expand-attribute'>
                  <with-param name='attr' value='separatorAttr'/>
               </call-template>
            </if>
         </code:arguments>
      </code:method-call>
   </template>

   <template match='XElement el &amp;&amp; el.Name == c + "next-match"' mode='src:statement'>
      <param name='packageManifest' as='XElement' tunnel='yes' required='yes'/>
      <param name='context' as='XElement?' tunnel='yes'/>
      <param name='output' as='XElement' tunnel='yes'/>

      <call-template name='xcst:validate-attribs'>
         <with-param name='el' value='el'/>
         <with-param name='optional' value='new[] { "with-params", "tunnel-params" }'/>
      </call-template>

      <call-template name='xcst:validate-children'>
         <with-param name='el' value='el'/>
         <with-param name='allowed' value='new[] { "with-param" }'/>
      </call-template>

      <call-template name='xcst:validate-with-param'>
         <with-param name='el' value='el'/>
      </call-template>

      <call-template name='xcst:require-output'>
         <with-param name='el' value='el'/>
      </call-template>

      <if test='!(context != null)'>
         <message terminate='yes' error-code='XCST9104' error-data='src_error_object(el)' transform-text='trim'>
            There is no current template rule.
         </message>
      </if>

      <variable name='thisRuleMode' value='src_this_rule_mode(el)'/>

      <choose>
         <when test='thisRuleMode != null'>
            <variable name='meta' value='packageManifest
               .Elements(xcst + "mode")
               .First(p => p.Attribute("visibility")!.Value != "hidden"
                  &amp;&amp; p.Attribute("name")!.Value == thisRuleMode)'/>
            <code:method-call>
               <call-template name='src:line-number'>
                  <with-param name='el' value='el'/>
               </call-template>
               <copy-of value='src_template_member(meta)'/>
               <code:arguments>
                  <call-template name='src:call-template-context'>
                     <with-param name='el' value='el'/>
                  </call-template>
                  <copy-of value='select(output, src + "reference", code)'/>
               </code:arguments>
            </code:method-call>
         </when>
         <otherwise>
            <code:method-call name='Invoke'>
               <code:method-call name='{src_all_modes_method_name}'>
                  <code:this-reference/>
                  <code:arguments>
                     <code:property-reference name='Mode'>
                        <copy-of value='select(context, src + "reference", code)'/>
                     </code:property-reference>
                     <copy-of value='select(output, src + "reference", code)'/>
                  </code:arguments>
               </code:method-call>
               <code:arguments>
                  <call-template name='src:call-template-context'>
                     <with-param name='el' value='el'/>
                  </call-template>
               </code:arguments>
            </code:method-call>
         </otherwise>
      </choose>
   </template>

   <function name='src_this_rule_mode' as='string?'>
      <param name='el' as='XElement'/>

      <variable name='thisRule' value='el
         .Ancestors(c + "template")
         .Take(1)
         .Where(p => p.Attribute("match") != null)
         .FirstOrDefault()'/>

      <variable name='thisModes' value='
         (thisRule != null) ?
            xcst_template_modes(thisRule)
            : System.Array.Empty&lt;string>()'/>

      <if test='thisModes.Length == 1
            &amp;&amp; thisModes[0] != "#all"
            &amp;&amp; !el.Ancestors(c + "delegate").Any()'>
         <return value='thisModes[0]'/>
      </if>

      <return value='null'/>
   </function>

</module>
